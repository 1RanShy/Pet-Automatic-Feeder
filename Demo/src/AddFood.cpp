#include "AddFood.h"
#include "SR04.h"
#include "Servo.h"
#include "globalVar.h"
#include "HumanSensor.h"
#include "Pump.h"
#include <iostream>
#include <thread>
using namespace std;
/*
	This is a thread to :
	1. Switch between automatic feeding and manual feeding mode
	2. Detect whether the pet is eating using a human body sensor
	3. In automatic feeding mode: Automatically add food by using an ultrasonic distance sensor to determine the remaining amount of food.
*/



/*
	Automatically detect whether the food has decreased, and if so, refill the food
	Detect frequency : 1 time/s
	The timer will call this function.
*/
void timerCallback1()
{
	PumpControl pump(pumpPin);
	pump.stop();
	/*
	After detection and experimentation:

	The strong electric current (about 100mA) generated by the water pump during operation interferes with the normal operation of the circuit, causing instability in the operation of SR04 and resulting in unstable distance measurement.

	Solution:

	Turn off the water pump before turning on SR04 each time.
*/
	// auto mode
	if(autoAddFoodFlag == 1)
	{
		SR04 foodDtect(foodSensorTrigger,foodSensorEcho);
		Servo addFood(servoAddFood);
		SR04 waterDetect(waterSensorTrigger,waterSensorEcho);
		
		float foodLeft = foodDtect.get_distance();
		cout << foodLeft << "cm" << endl;
		if(foodLeft < foodFull)//only change here
		{
			addFood.setAngle(0);
			//food is full ,stop adding food
		}
		if(foodLeft > foodEmpty)
		{
			addFood.setAngle(180);
			//food is empty, add food
		}


		float waterLeft = waterDetect.get_distance();
		cout << waterLeft << "cm" << endl;
		
		if(waterLeft < waterFull)//only change here
		{
			pump.stop();
			
			/*
				Check if the cat is eating while the water pump is not working. 
				This is because the strong electric current generated by the water pump during operation interferes with the normal operation of the human body sensor. 
				Therefore, I can only use the human body sensor to detect the cat when the water pump is not working.
			*/
			//------------start to check if cat is eating---------------------
			if(findCatFlag == true)
			{
				HumanSensor sensor(humanSensorPin);
				
				datsToSendLock.lock();

				if(sensor.detect() == 0)
				{
					for(int i = 0; i<5; i++)
					{
						dataToSend[i] = '3';
					}
				}

				else if((sensor.detect() == 1))
				{
					for(int i = 0; i<5; i++)
					{
						dataToSend[i] = '4';
					}					
				}
				datsToSendLock.unlock();
				findCatFlag = false;
			}
			//---------------------------------

		}

		if(waterLeft > waterEmpty)
		{
			pump.start();
			if(findCatFlag == true)
			{
				findCatFlag = false;
			}
		}
	}
	// manuuly  mode
	else
	{
		SR04 foodDtect(foodSensorTrigger,foodSensorEcho);
		Servo addFood(servoAddFood);
		SR04 waterDetect(waterSensorTrigger,waterSensorEcho);
		PumpControl pump(pumpPin);

		cout << "Manully add Food" << endl;
		cout << "Engine Stop" << endl;
		
		pump.stop();
		addFood.setAngle(0);

		if(findCatFlag == true)
		{
			HumanSensor sensor(humanSensorPin);

			
			datsToSendLock.lock();
			if(sensor.detect() == 0)
			{
				for(int i = 0; i<5; i++)
				{
					dataToSend[i] = '3';
				}
			}
			else if((sensor.detect() == 1))
			{
				for(int i = 0; i<5; i++)
				{
					dataToSend[i] = '4';
				}					
			}
			datsToSendLock.unlock();
			// findCatFlagLock.lock();
			findCatFlag = false;
			// findCatFlagLock.unlock();
		}
	}

#ifdef TEST
	// cout << Bluetooth Test <<  endl;
	// cout << "already add" << endl;
	// datsToSendLock.lock();
    // dataToSend[0] = 'C';
    // dataToSend[1] = 'C';
    // dataToSend[2] = 'C';
    // dataToSend[3] = 'C';
    // dataToSend[4] = 99;
    // datsToSendLock.unlock();
#endif
}

void AddFood::scanFood() {
    running = true;
	gpioSetTimerFunc(0, 1000, &timerCallback1);//1s callback timer
    while (running) //while(1)
    {

    }
}

void AddFood::registerCallback(AddFoodcallback* af){
	addFoodCallbacks.push_back(af);
}

void AddFood::start(){
	gpioInitialise();
	t = thread(&AddFood::scanFood,this);
}

void AddFood::stop(){
	// running = false;
	t.join();
}
